# Workflow preprocesses WGS sequences in FASTQ or BAM, then
# runs original PCAWG BWA-MEM alignment, different QC metrics are 
# also collected at convenient steps

workflow:
  name:  bwa-mem-wgs-aligner
  version: "0.0.20"

  env_var:  # JT will not pass these as parameters for tasks, instead, JT may check existence of the env variable
    SCORE_TOKEN:
      type: string
      is_required: true
    SONG_TOKEN:
      type: string
      is_required: true
  input:
    metadata_yaml:
      type: string
      is_file: true
      is_required: true
    picard_jar:
      type: string
      is_file: true
      default: "[picard.jar]https://github.com/broadinstitute/picard/releases/download/2.18.16/picard.jar"
    dckr_pcawg2_song:
      type: string
      default: quay.io/pancaner/song-uperations:0.1.0  # need to verify
    dckr_score:
      type: string
      default: overture/score:1.5.0  # need to verify
    pcawg_aligner_dockstore_url:
      type: string
      is_file: true
      default: "[pcawg-bwa-mem.cwl]https://dockstore.org/api/api/ga4gh/v2/tools/quay.io%2Fpancancer%2Fpcawg-bwa-mem-workflow/versions/2.6.8_1.4/plain-CWL/descriptor/Dockstore.cwl"
    reference_gz_amb:
      type: string
      is_file: true
      default: "[genome.fa.gz.64.amb]https://dcc.icgc.org/api/v1/download?fn=/PCAWG/reference_data/pcawg-bwa-mem/genome.fa.gz.64.amb"
    reference_gz_sa:
      type: string
      is_file: true
      default: "[genome.fa.gz.64.sa]https://dcc.icgc.org/api/v1/download?fn=/PCAWG/reference_data/pcawg-bwa-mem/genome.fa.gz.64.sa"
    reference_gz_pac:
      type: string
      is_file: true
      default: "[genome.fa.gz.64.pac]https://dcc.icgc.org/api/v1/download?fn=/PCAWG/reference_data/pcawg-bwa-mem/genome.fa.gz.64.pac"
    reference_gz_ann:
      type: string
      is_file: true
      default: "[genome.fa.gz.64.ann]https://dcc.icgc.org/api/v1/download?fn=/PCAWG/reference_data/pcawg-bwa-mem/genome.fa.gz.64.ann"
    reference_gz_bwt:
      type: string
      is_file: true
      default: "[genome.fa.gz.64.bwt]https://dcc.icgc.org/api/v1/download?fn=/PCAWG/reference_data/pcawg-bwa-mem/genome.fa.gz.64.bwt"
    reference_gz_fai:
      type: string
      is_file: true
      default: "[genome.fa.gz.fai]https://dcc.icgc.org/api/v1/download?fn=/PCAWG/reference_data/pcawg-bwa-mem/genome.fa.gz.fai"
    reference_gz:
      type: string
      is_file: true
      default: "[genome.fa.gz]https://dcc.icgc.org/api/v1/download?fn=/PCAWG/reference_data/pcawg-bwa-mem/genome.fa.gz"

  tasks:
    validate_metadata:
      tool: validate_metadata
      input:
        metadata_yaml: metadata_yaml

    download:
      tool: download
      input:
        metadata_json: metadata_json@validate_metadata
        input_format: input_format@validate_metadata

    fastq_to_sam:
      tool: fastq_to_sam
      input:
        metadata_json: metadata_json@validate_metadata
        download_files: download_files@download
        picard_jar: picard_jar
        input_format: input_format@validate_metadata

    revert_bam:
      tool: revert_bam
      input:
        metadata_json: metadata_json@validate_metadata
        download_files: download_files@download
        picard_jar: picard_jar
        input_format: input_format@validate_metadata

    replace_readgroup:
      tool: replace_readgroup
      input:
        metadata_json: metadata_json@validate_metadata
        picard_jar: picard_jar
        input_format: input_format@validate_metadata
        unaligned_by_rg_dir: unaligned_by_rg_dir@revert_bam

    add_comment:
      tool: add_comment
      input:
        metadata_json: metadata_json@validate_metadata
        bams: bams@fastq_to_sam
        picard_jar: picard_jar
        input_format: input_format@validate_metadata
        unaligned_rg_replace_dir: unaligned_rg_replace_dir@replace_readgroup

    lane_bam_qc:
      tool: lane_bam_qc
      input:
        lane_bams: bams@add_comment
        picard_jar: picard_jar

    pcawg_aligner:
      tool: pcawg_aligner
      input:
        cwl_file: pcawg_aligner_dockstore_url
        lane_bams: bams@add_comment
        output_file_basename: aligned_bam_basename@add_comment
        reference_gz_amb: reference_gz_amb
        reference_gz_sa: reference_gz_sa
        reference_gz_pac: reference_gz_pac
        reference_gz_ann: reference_gz_ann
        reference_gz_bwt: reference_gz_bwt
        reference_gz_fai: reference_gz_fai
        reference_gz: reference_gz

    aligned_bam_qc:
      tool: aligned_bam_qc
      input:
        picard_jar: picard_jar
        aligned_bam: merged_output_bam@pcawg_aligner
        reference_sequence: reference_gz  # may need unzipped version

    aligned_bam_oxog_metrics:
      tool: aligned_bam_oxog_metrics
      input:
        picard_jar: picard_jar
        aligned_bam: merged_output_bam@pcawg_aligner
        reference_sequence: reference_gz  # may need unzipped version

    # may add more QCs if needed

    create_tar:
      tool: create_tar
      input:
        aliquot_id: ###
        sequencing_strategy: ###
        genome: ###

    generate_song_payload:
      tool: generate_song_payload
      input:
        metadata_yaml: metadata_yaml
        bam_file: ###
        bai_file: ###
        tar_file: create_tar@tar_file

    upload_song_payload_collab:
      tool: upload_song_payload
      input:
        payload: generate_song_payload@payload
        song_metadata_url: ### SONG_COLLAB_URL
        study: ###
        access_token_global_variable: SONG_TOKEN

    upload_song_payload_aws:
      tool: upload_song_payload
      input:
        payload: generate_song_payload@payload
        song_metadata_url: ### SONG_AWS_URL
        study: ###
        access_token_global_variable: SONG_TOKEN

    save_song_payload_collab:
      tool: save_song_payload
      input:
        song_metadata_url: ### SONG_COLLAB_URL
        study: ###
        upload_id: upload_song_payload_collab@uploadId
        access_token_global_variable: SONG_TOKEN

    save_song_payload_aws:
      tool: save_song_payload
      input:
        song_metadata_url: ### SONG_AWS_URL
        study: ###
        upload_id: upload_song_payload_aws@uploadId
        access_token_global_variable: SONG_TOKEN

    create_manifest_file_collab:
      tool: create_manifest_file
      input:
        input_dir: ###
        song_metadata_url: ### SONG_COLLAB_URL
        study: ###
        analysis_id: save_song_payload_collab@analysis_id
        manifest_file: manifest.txt

    create_manifest_file_aws:
      tool: create_manifest_file
      input:
        input_dir: ###
        song_metadata_url: ### SONG_AWS_URL
        study: ###
        analysis_id: save_song_payload_aws@analysis_id
        manifest_file: manifest.txt

    score_upload_collab:
      tool: score_upload
      input:
        manifest_file: create_manifest_file_collab@manifest_file
        input_dir: ###
        song_metadata_url: ### SONG_COLLAB_URL
        storage_url: ### STORAGE_URL
        access_token_global_variable: SCORE_TOKEN

    score_upload_aws:
      tool: score_upload
      input:
        manifest_file: create_manifest_file_aws@manifest_file
        input_dir: ###
        song_metadata_url: ### SONG_AWS_URL
        storage_url: ### STORAGE_URL
        access_token_global_variable: SCORE_TOKEN

    publish_song_payload_collab:
      tool: publish_song_payload
      input:
        song_metadata_url: ### SONG_COLLAB_URL
        study: ### study
        analysis_id: save_song_payload_collab@analysis_id
        access_token_global_variable: SONG_COLLAB_URL

    publish_song_payload_aws:
      tool: publish_song_payload
      input:
        song_metadata_url: ### SONG_AWS_URL
        study: ### study
        analysis_id: save_song_payload_aws@analysis_id
        access_token_global_variable: SONG_AWS_URL

# A workflow is made up with one or more tools
# Each tool can have its own docker imagine if desirable
tools:
  validate_metadata:
    command: validate_metadata.py

    input:
      metadata_yaml:
        type: string
        is_file: true

    output:
      input_format:
        type: string
      metadata_json:
        type: string
        is_file: true

  download:
    command: download.py

    input:
      metadata_json:
        type: string
        is_file: true
      input_format:
        type: string

    output:
      download_files:
        type: array
        items:
          type: object

  fastq_to_sam:
    command: fastq_to_sam.py

    input:
      metadata_json:
        type: string
        is_file: true
      picard_jar:
        type: string
        is_file: true
      download_files:
        type: array
        items:
          type: object
      input_format:
        type: string

    output:
      bams:
        type: array
        items:
          type: string
          is_file: true
          glob_pattern: "*.bam"

  revert_bam:
    command: revert_bam.py

    input:
      metadata_json:
        type: string
        is_file: true
      picard_jar:
        type: string
        is_file: true
      download_files:
        type: array
        items:
          type: object
      input_format:
        type: string

    output:
      unaligned_by_rg_dir:
        type: string

  replace_readgroup:
    command: replace_readgroup.py

    input:
      metadata_json:
        type: string
        is_file: true
      picard_jar:
        type: string
        is_file: true
      unaligned_by_rg_dir:
        type: string
      input_format:
        type: string

    output:
      unaligned_rg_replace_dir:
        type: string

  add_comment:
    command: add_comment.py

    input:
      metadata_json:
        type: string
        is_file: true
      picard_jar:
        type: string
        is_file: true
      unaligned_rg_replace_dir:
        type: string
      input_format:
        type: string
      bams:
        type: array
        items:
          type: string
          is_file: true
          glob_pattern: "*.bam"

    output:
      aligned_bam_basename:
        type: string
      bams:
        type: array
        items:
          type: string
          is_file: true
          glob_pattern: "*.bam"

  lane_bam_qc:
    command: |
      python -c '
      import sys
      import json
      import subprocess
      lane_bams = sys.argv[1].split(",")

      metrics = []
      for bam in lane_bams:
        metrics_file = "%s.quality_yield_metrics.txt" % bam
        command = "java -jar ${picard_jar} CollectQualityYieldMetrics I=%s O=%s" % (bam, metrics_file)
        try:
          p = subprocess.Popen([command], stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
          stdout, stderr = p.communicate()
        except Exception as e:
          exit(stderr)
        metrics.append(metrics_file)

      print(json.dumps({
        "metrics": metrics
      }))

      ' ${sep=',' lane_bams} > output.json 2> std.err

    input:
      picard_jar:
        type: string
        is_file: true
      lane_bams:
        type: array
        items:
          type: string
          is_file: true
    output:
      metrics:
        type: array
        items:
          type: string
          is_file: true
          glob_pattern: "*.quality_yield_metrics.txt"

  pcawg_aligner:  # this is really a PCAWG BWA-MEM CWL workflow wrapper
    command: |
      pcawg_aligner.py --cwl_file ${cwl_file} \
        --reads ${sep=' ' lane_bams} \
        --output_dir datastore \
        --output_file_basename ${output_file_basename} \
        --reference_gz_amb ${reference_gz_amb} \
        --reference_gz_sa ${reference_gz_sa} \
        --reference_gz_pac ${reference_gz_pac} \
        --reference_gz_ann ${reference_gz_ann} \
        --reference_gz_bwt ${reference_gz_bwt} \
        --reference_gz_fai ${reference_gz_fai} \
        --reference_gz ${reference_gz}
    input:
      cwl_file:
        type: string
        is_file: true
      lane_bams:
        type: array
        items:
          type: string
          is_file: true
      output_file_basename:
        type: string
      reference_gz_amb:
        type: string
        is_file: true
      reference_gz_sa:
        type: string
        is_file: true
      reference_gz_pac:
        type: string
        is_file: true
      reference_gz_ann:
        type: string
        is_file: true
      reference_gz_bwt:
        type: string
        is_file: true
      reference_gz_fai:
        type: string
        is_file: true
      reference_gz:
        type: string
        is_file: true
    output:  # output section is ignored for now
      merged_output_bam:
        type: string
        is_file: true
        value: "${output_file_basename}.bam"
      merged_output_bai:
        type: string
        is_file: true
        value: "${output_file_basename}.bam.bai"
      merged_output_metrics:
        type: string
        is_file: true
        value: "${output_file_basename}.bam.metrics"
      merged_output_stats:
        type: string
        is_file: true
        value: "${output_file_basename}.bam.stats.txt"

  aligned_bam_qc:  # this requires RScript, install it by 'apt install r-base-core'
    command: |
      java -Xms5000m -jar ${picard_jar} CollectMultipleMetrics \
        I=${aligned_bam} \
        O=multiple_metrics \
        R=${reference_sequence} \
        ASSUME_SORTED=true \
        PROGRAM="null" \
        PROGRAM=CollectBaseDistributionByCycle \
        PROGRAM=CollectAlignmentSummaryMetrics \
        PROGRAM=CollectInsertSizeMetrics \
        PROGRAM=MeanQualityByCycle \
        PROGRAM=QualityScoreDistribution \
        PROGRAM=CollectSequencingArtifactMetrics \
        PROGRAM=CollectQualityYieldMetrics \
        METRIC_ACCUMULATION_LEVEL="null" \
        METRIC_ACCUMULATION_LEVEL="ALL_READS" \
        METRIC_ACCUMULATION_LEVEL="SAMPLE" \
        METRIC_ACCUMULATION_LEVEL="LIBRARY" \
        METRIC_ACCUMULATION_LEVEL="READ_GROUP"
    input:
      picard_jar:
        type: string
        is_file: true
      aligned_bam:
        type: string
      reference_sequence:
        type: string
        is_file: true
    output:
      metrics_files:
        type: array
        items:
          type: string
          is_file: true
          glob_pattern: "multiple_metrics*.txt"

  aligned_bam_oxog_metrics:
    command: |
      java -jar ${picard_jar} CollectOxoGMetrics \
        I=${aligned_bam} \
        O=oxoG_metrics.txt \
        R=${reference_sequence}
    input:
      picard_jar:
        type: string
        is_file: true
      aligned_bam:
        type: string
      reference_sequence:
        type: string
        is_file: true

  create_tar:
    command: |
      TAR_NAME=${aliquot_id}.${number_of_lanes}.$(date +%Y%m%d).wgs.qc_metrics.tar.gz \
      && docker_pull ${dckr_pcawg2_song} \
      && docker run \
          -v ${task_download_workdir}:/data \
          -v ${task_aligned_bam_qc_wkdir}:/aligned_bam_qc \
          -v ${lane_unaligned_dir}:/unaligned_seq_qc \
          -v ${task_aligned_bam_oxog_metrics_wkdir}:/oxog_metrics \
          ${dckr_pcawg2_song} python3 create_tar.py \
            /data/$TAR_NAME \
            /aligned_bam_qc:aligned_bam_qc:multiple_metrics.* \
            /unaligned_seq_qc:unaligned_seq_qc:*.lane.bam.quality_yield_metrics.txt \
            /oxog_metrics:oxog_metrics:oxoG_metrics.txt \
      && echo "{ \"tar_file\": \"${task_download_wkdir}/$TAR_NAME\" }" > output.json

    input:
      aliquot_id:
        type: string
      number_of_lanes:
        type: integer
      dckr_pcawg2_song:
        type: string
      task_download_wkdir:
        type: string
      task_aligned_bam_qc_wkdir:
        type: string
      lane_unaligned_dir:
        type: string
      task_aligned_bam_oxog_metrics_wkdir:
        type: string

    output:
      tar_file:
        type: string
        is_file: true

  generate_song_payload:
    command: |
      docker_pull ${dckr_pcawg2_song} \
      && docker run \
        -v $(pwd):/data \
        -v ${metadata_yaml}:/metadata.yaml:ro \  # should these file be mounted directly under root?
        -v ${bam_file}:/ef11a76c-fc8a-5098-85b6-ef22195b21fe.1.20190201.wgs.grch37.bam \
        -v ${bai_file}:/ef11a76c-fc8a-5098-85b6-ef22195b21fe.1.20190201.wgs.grch37.bam.bai \
        -v ${tar_file}:/${tar_file} \
        -v ${lane_unaligned_dir}:/lane_unaligned \
        -v ${task_aligned_bam_oxog_metrics_wkdir}:/task_aligned_bam_oxog_metrics_wkdir \
        -v ${task_aligned_bam_qc_wkdir}:/task_aligned_bam_qc_wkdir \
        dckr_pcawg2_song python3 generate_song_payload.py \
          /metadata.yaml \
          /$bam_file \
          /$bai_file \
          /$tar_file \
          /lane_unaligned \
          /task_aligned_bam_oxog_metrics_wkdir \
          /task_aligned_bam_qc_wkdir | jq > payload.json \
      && echo "{ \"payload\": \"$(pwd)/payload.json\" }" > output.json

    input:
      dckr_pcawg2_song:
        type: string
      metadata_yaml:
        type: string
        is_file: true
      bam_file:
        type: string
        is_file: true
      bai_file:
        type: string
        is_file: true
      tar_file:
        type: string
        is_file: true
      lane_unaligned_dir:
        type: string
    output:
      payload:
        type: string
        is_file: true

  upload_song_payload:
    command: |
      docker pull ${dckr_pcawg2_song} \
      && docker run \
          --net=host \
          -e ACCESS_TOKEN=$(access_token_global_variable) \  # JT will not pass tokens
          -v ${payload}:/payload.json \
          ${dckr_pcawg2_song} \
          uperation sing upload \
          ${song_metadata_url} ACCESS_TOKEN ${study} /payload.json > output.json
    input:
      dckr_pcawg2_song:  # Docker image
        type: string
      payload:
        type: string
        is_file: true
      song_metadata_url:
        type: string
      study:
        type: string
      access_token_global_variable:
        type: string
    output:
      status:
        type: string
      uploadId:
        type: string

  save_song_payload:
    command: |
      docker pull ${dckr_pcawg2_song} \
      && docker run \
          --net=host \
          -e ACCESS_TOKEN=$(access_token_global_variable) \  # JT will not pass tokens
          ${dckr_pcawg2_song} \
          uperation sing save \
          ${song_metadata_url} ACCESS_TOKEN ${study} ${upload_id} > output.json
    input:
      dckr_pcawg2_song:  # Docker image
        type: string
      song_metadata_url:
        type: string
      study:
        type: string
      upload_id:
        type: string
      access_token_global_variable:  # JT does not pass tokens
        type: string
    output:
      status:
        type: string
      analysis_id:
        type: string

  create_manifest_file:
    command: |
      docker pull ${dckr_pcawg2_song} \
      && docker run \
          --net=host \
          -v $(pwd):/output \
          -v $(input_dir):/data \
          ${dckr_pcawg2_song} \
          uperation sing manifest \
          ${song_metadata_url} ${study} ${analysis_id} ./ ${manifest_file} \
      && echo "{\"manifest_file\": \"${manifest_file}\" }" > output.json
    input:
      dckr_pcawg2_song:  # Docker image
        type: string
      input_dir:
        type: string
      song_metadata_url:
        type: string
      study:
        type: string
      analysis_id:
        type: string
      manifest_file:
        type: string
        is_file: true
    output:
      manifest_file:
        type: string
        is_file: true

  score_upload:
    command: |
      docker pull ${dckr_score} \
      && docker run \
          --net=host \
          -v ${manifest_file}:/manifest.txt \
          -v ${input_dir}:/data \
          -e ACCESS_TOKEN=$(access_token_global_variable) \  # JT does not pass tokens
          -e STORAGE_URL=${storage_url} \
          -e METADATA_URL=${song_metadata_url} \
          ${dckr_score} \
          bin/score-client upload --manifest /manifest.txt --force
    input:
      dckr_score:
        type: string
      manifest_file:
        type: string
        is_file: true
      input_dir:
        type: string
      song_metadata_url:
        type: string
      storage_url:
        type: string
      access_token_global_variable:
        type: string

  publish_song_payload:
    command: |
      docker pull ${dckr_pcawg2_song} \
      && docker run \
          --net=host \
          ${dckr_pcawg2_song} \
          uperation publish \
          ${song_metadata_url} $(access_token_global_variable) ${study} ${analysis_id}
    input:
      dckr_pcawg2_song:  # Docker image
        type: string
      song_metadata_url:
        type: string
      study:
        type: string
      analysis_id:
        type: string
      access_token_global_variable:
        type: string
